<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The Hex Book, all in one place.">
    <meta name="author" content="petrak@, Alwinfy">
    <link rel="icon" href="icon.png">

    <title>Hex Book</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css"
          integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.3.0/font/bootstrap-icons.css">
    <style>
      summary { display: list-item; }

      details.spell-collapsible {
        display: inline-block;
        border: 1px solid #aaa;
        border-radius: 4px;
        padding: .5em .5em 0;
        margin-bottom: .5em;
      }

      summary.collapse-spell {
        font-weight: bold;
        margin: -.5em -.5em 0;
        padding: .5em;
      }

      details.spell-collapsible[open] {
        padding: .5em;
      }

      details[open] summary.collapse-spell {
        border-bottom: 1px solid #aaa;
        margin-bottom: .5em;
      }

      details .collapse-spell::before {
        content: "Click to show spell";
      }
      details[open] .collapse-spell::before {
        content: "Click to hide spell";
      }
      blockquote.crafting-info {
        font-size: inherit;
      }
      a.toggle-link {
        margin-left: 0.5em;
      }
      a.permalink {
        margin-left: 0.5em;
      }
      a.permalink:hover {
        color: lightgray;
      }
      p {
        margin: 0.5ex 0;
      }
      p.fake-li {
        margin: 0;
      }
      p.fake-li::before {
        content: "\2022";
        margin: 1ex;
      }
      .linkout::before {
        content: "Link: ";
      }
      p.todo-note {
        font-style: italic;
        color: lightgray;
      }
      .obfuscated {
        filter: blur(1em);
      }
      .spoilered {
        filter: blur(1ex);
        -moz-transition: filter 0.04s linear;
      }
      .spoilered:hover {
        filter: blur(0.5ex);
      }
      .spoilered.unspoilered {
        filter: blur(0);
      }
      canvas.spell-viz {
        --dot-color: #777f;
        --start-dot-color: #f009;
        --moving-dot-color: #0fa9;

        --path-color: darkgray;
        --visited-path-color: #0c8;

        --dot-scale: 0.0625;
        --moving-dot-scale: 0.125;
        --line-scale: 0.08333;
        --pausetext-scale: 0.5;
      }

    </style>
    <noscript>
        <style>
        /* for accessibility */
        .spoilered {
          filter: none !important;
        }

        </style>
    </noscript>
    <script>
      "use strict";
      const speeds = [0, 0.25, 0.5, 1, 2, 4];
      const scrollThreshold = 100;
      const rfaQueue = [];
      function startAngle(str) {
        switch (str) {
          case "east": return 0;
          case "north_east": return 1;
          case "north_west": return 2;
          case "west": return 3;
          case "south_west": return 4;
          case "south_east": return 5;
          default: return 0;
        }
      }
      function offsetAngle(str) {
        switch (str) {
          case "w": return 0;
          case "q": return 1;
          case "a": return 2;
          case "s": return 3;
          case "d": return 4;
          case "e": return 5;
          default: return -1;
        }
      }
      function initializeElem(canvas) {
        const str = canvas.dataset.string;
        let angle = startAngle(canvas.dataset.start);
        const perWorld = canvas.dataset.perWorld === "True";

        // build geometry
        const points = [[0, 0]];
        let lastPoint = points[0];
        let minPoint = lastPoint, maxPoint = lastPoint;
        for (const ch of "w" + str) {
          const addAngle = offsetAngle(ch);
          if (addAngle < 0) continue;
          angle = (angle + addAngle) % 6;
          const trueAngle = Math.PI / 3 * angle;

          const [lx, ly] = lastPoint;
          const newPoint = [lx + Math.cos(trueAngle), ly - Math.sin(trueAngle)];

          points.push(newPoint);
          lastPoint = newPoint;

          const [mix, miy] = minPoint;
          minPoint = [Math.min(mix, newPoint[0]), Math.min(miy, newPoint[1])];
          const [max, may] = maxPoint;
          maxPoint = [Math.max(max, newPoint[0]), Math.max(may, newPoint[1])];
        }
        const size = Math.min(canvas.width, canvas.height) * 0.8;
        const scale = size / Math.max(3, Math.max(maxPoint[1] - minPoint[1], maxPoint[0] - minPoint[0]));
        const center = [(minPoint[0] + maxPoint[0]) * 0.5, (minPoint[1] + maxPoint[1]) * 0.5];
        const truePoints = points.map(p => [canvas.width * 0.5 + scale * (p[0] - center[0]), canvas.height * 0.5 + scale * (p[1] - center[1])]);
        let uniqPoints = [];
        l1: for (const point of truePoints) {
          for (const pt of uniqPoints) {
            if (Math.abs(point[0] - pt[0]) < 0.00001 && Math.abs(point[1] - pt[1]) < 0.00001) {
              continue l1;
            }
          }
          uniqPoints.push(point);
        }

        // rendering code
        const speed = 0.0025;
        const context = canvas.getContext("2d");
        const negaProgress = -3;
        let progress = 0;
        let scrollTimeout = 1e309;
        let speedLevel = 3;
        let speedIncrement = 0;
        function speedScale() {
          return speeds[speedLevel];
        }

        const style = getComputedStyle(canvas);
        const getProp = n => style.getPropertyValue(n);

        const tick = dt => {
          scrollTimeout += dt;
          if (canvas.offsetParent === null) return;

          const strokeStyle = getProp("--path-color");
          const strokeVisitedStyle = getProp("--visited-path-color");

          const startDotStyle = getProp("--start-dot-color");
          const dotStyle = getProp("--dot-color");
          const movDotStyle = getProp("--moving-dot-color");

          const strokeWidth = scale * +getProp("--line-scale");
          const dotRadius = scale * +getProp("--dot-scale");
          const movDotRadius = scale * +getProp("--moving-dot-scale");
          const pauseScale = scale * +getProp("--pausetext-scale");


          if (!perWorld) {
            progress += speed * dt * (progress > 0 ? speedScale() : Math.sqrt(speedScale()));
          }
          if (progress >= truePoints.length - 1) {
            progress = negaProgress;
          }
          let ix = Math.floor(progress), frac = progress - ix, core = null, fadeColor = 0;
          if (ix < 0) {
            const rawFade = 2 * progress / negaProgress - 1;
            fadeColor = 1 - Math.abs(rawFade);
            context.strokeStyle = rawFade > 0 ? strokeVisitedStyle : strokeStyle;
            ix = rawFade > 0 ? truePoints.length - 2 : 0;
            frac = +(rawFade > 0);
          } else {
            context.strokeStyle = strokeVisitedStyle;
          }

          const [lx, ly] = truePoints[ix];
          const [rx, ry] = truePoints[ix + 1];
          core = [lx + (rx - lx) * frac, ly + (ry - ly) * frac];


          context.clearRect(0, 0, canvas.width, canvas.height);
          context.beginPath();
          context.lineWidth = strokeWidth;
          context.moveTo(truePoints[0][0], truePoints[0][1]);
          for (let i = 1; i < ix + 1; i++) {
            context.lineTo(truePoints[i][0], truePoints[i][1]);
          }
          context.lineTo(core[0], core[1]);
          context.stroke();
          context.beginPath();
          context.strokeStyle = strokeStyle;
          context.moveTo(core[0], core[1]);
          for (let i = ix + 1; i < truePoints.length; i++) {
            context.lineTo(truePoints[i][0], truePoints[i][1]);
          }
          context.stroke();

          for (let i = 0; i < uniqPoints.length; i++) {
            context.beginPath();
            context.fillStyle = (i == 0 && !perWorld) ? startDotStyle : dotStyle;
            const radius = (i == 0 && !perWorld) ? movDotRadius : dotRadius;
            context.arc(uniqPoints[i][0], uniqPoints[i][1], radius, 0, 2 * Math.PI);
            context.fill();
          }

          if (!perWorld) {
            context.beginPath();
            context.fillStyle = movDotStyle;
            context.arc(core[0], core[1], movDotRadius, 0, 2 * Math.PI);
            context.fill();
          }
          if (fadeColor) {
            context.fillStyle = `rgba(255, 255, 255, ${fadeColor})`;
            context.fillRect(0, 0, canvas.width, canvas.height);
          }
          if (scrollTimeout <= 2000) {
            context.fillStyle = `rgba(200, 200, 200, ${(2000 - scrollTimeout) / 1000})`;
            context.font = `${pauseScale}px sans-serif`;
            context.fillText(speedScale() ? speedScale() + "x" : "Paused", 0.2 * scale, canvas.height - 0.2 * scale);
          }
        };
        rfaQueue.push(tick);

        // scrolling input
        if (!perWorld) {
          canvas.addEventListener("wheel", ev => {
            speedIncrement += ev.deltaY;
            const oldSpeedLevel = speedLevel;
            if (speedIncrement >= scrollThreshold) {
              speedLevel--;
            } else if (speedIncrement <= -scrollThreshold) {
              speedLevel++;
            }
            if (oldSpeedLevel != speedLevel) {
              speedIncrement = 0;
              speedLevel = Math.max(0, Math.min(speeds.length - 1, speedLevel));
              scrollTimeout = 0;
            }
            ev.preventDefault();
          });
        }
      }
      function hookLoad(elem) {
        let init = false;
        const canvases = elem.querySelectorAll("canvas");
        elem.addEventListener("toggle", () => {
          if (!init) {
            canvases.forEach(initializeElem);
            init = true;
          }
        });
      }
      function hookToggle(elem) {
        const details = Array.from(document.querySelectorAll("details." + elem.dataset.target));
        elem.addEventListener("click", () => {
          if (details.some(x => x.open)) {
            details.forEach(x => x.open = false);
          } else {
            details.forEach(x => x.open = true);
          }
        });
      }
      const params = new URLSearchParams(document.location.search);
      function hookSpoiler(elem) {
        if (params.get("nospoiler") !== null) {
          elem.classList.add("unspoilered");
        } else {
          const thunk = ev => {
            if (!elem.classList.contains("unspoilered")) {
              ev.preventDefault();
              ev.stopImmediatePropagation();
              elem.classList.add("unspoilered");
            }
            elem.removeEventListener("click", thunk);
          };
          elem.addEventListener("click", thunk);

          if (elem instanceof HTMLAnchorElement) {
            const href = elem.getAttribute("href");
            if (href.startsWith("#")) {
              elem.addEventListener("click", () => document.getElementById(href.substring(1)).querySelector(".spoilered").classList.add("unspoilered"));
            }
          }
        }
      }
      document.addEventListener('DOMContentLoaded', () => {
        document.querySelectorAll('details.spell-collapsible').forEach(hookLoad);
        document.querySelectorAll('a.toggle-link').forEach(hookToggle);
        document.querySelectorAll('.spoilered').forEach(hookSpoiler);
        function tick(prevTime, time) {
          const dt = time - prevTime;
          for (const q of rfaQueue) {
            q(dt);
          }
          requestAnimationFrame(t => tick(time, t));
        }
        requestAnimationFrame(t => tick(t, t));
      });

    </script>

</head>
<body>
<div class="container" style="margin-top: 3em;">
    <blockquote>
        <h1>This is the online version of the Hexcasting documentation.</h1>
        <p>Embedded images and patterns are included, but not crafting recipes or items. There's an in-game book for
            those.</p>
        <p>Additionally, this is built from the latest code on GitHub. It may describe <b>newer</b> features that you
            may not necessarily have, even on the latest CurseForge version!</p>
        <p><b>Entries which are blurred are spoilers</b>. Click to reveal them, but be aware that they may spoil endgame
            progression. Alternatively, click <a href="?nospoiler">here</a> to get a version with all spoilers showing.
        </p>
    </blockquote>
</div>
<div class='container'><header class='jumbotron'><h1 class='book-title'>Hex Notebook</h1><p>I seem to have discovered a new method of magical arts, in which one draws patterns strange and wild onto a hexagonal grid. It fascinates me. I've decided to start a journal of my thoughts and findings.</p><p><a href='https://discord.gg/4xxHGYteWk'>Discord Server Link</a></p></header><nav><h2 id='table-of-contents' class='page-header'>Table of Contents<a href='javascript:void(0)' class='toggle-link small' data-target='toc-category'>(toggle all)</a><a href='#table-of-contents' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><details class='toc-category'><summary><a href='#patterns' class=''>Patterns</a></summary><ul><li><a href='#patterns/math_actions' class=''>HexKinetics Mathematics</a></li><li><a href='#patterns/actions' class=''>HexKinetics Patterns</a></li></ul></details><details class='toc-category'><summary><a href='#patterns/spells' class=''>Spells</a></summary><ul><li><a href='#patterns/spells/spells' class=''>HexKinetics Spells</a></li><li><a href='#patterns/spells/rotate_spells' class=''>Rotation Spells</a></li></ul></details><details class='toc-category'><summary><a href='#patterns/great_spells' class=''>Great Spells</a></summary><ul><li><a href='#patterns/great_spells/greater_translocation' class=''>Greater Translocation</a></li><li><a href='#patterns/great_spells/great_spells' class=''>Kinetics</a></li></ul></details></nav><main class='book-body'><section id='patterns'><h2 class='category-title page-header'>Patterns<a href='#patterns' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>A list of all the patterns I've discovered, as well as what they do.</p><div id='patterns/math_actions'><h3 class='entry-title page-header'>HexKinetics Mathematics<a href='#patterns/math_actions' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><div id='patterns/math_actions@hexkinetics:reflection/const'><h4 class='pattern-title'>Optician's Distillation (vector, vector → vector)<a href='#patterns/math_actions@hexkinetics:reflection/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='qqqqqdqqqqq' data-start='south_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: qqqqqdqqqqq</canvas></details><p>This operation retrieves two vectors from the stack and calculates a vector reflection of the first vector based on the second vector, which acts as a normal and defines the reflection plane.</p></div><br /><div id='patterns/math_actions@hexkinetics:hadamard/const'><h4 class='pattern-title'>Hadamard's Distillation (vector, vector → vector)<a href='#patterns/math_actions@hexkinetics:hadamard/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='awaqawa' data-start='west' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: awaqawa</canvas></details><p>Elements corresponding to the same columns of given vectors are multiplied together to form a new vector.</p></div><br /><div id='patterns/math_actions@hexkinetics:round/const'><h4 class='pattern-title'>Imprecision Purification (num/vec → num/vec)<a href='#patterns/math_actions@hexkinetics:round/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='aadeeaa' data-start='south_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: aadeeaa</canvas></details><p>Number or elements in given vector are rounded to the nearest whole.</p></div><br /><div id='patterns/math_actions@hexkinetics:get_vec/const'><h4 class='pattern-title'>Sphere Distillation (vec, num → list)<a href='#patterns/math_actions@hexkinetics:get_vec/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='qqqqqeddedq' data-start='south_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: qqqqqeddedq</canvas></details><p>Take a position and maximum distance on the stack, and combine them into a list of all block positions that are needed to create an hollow sphere of that range.</p></div><br /><div id='patterns/math_actions@hexkinetics:get_vec_from/const'><h4 class='pattern-title'>Span Distillation (vector, vector → list)<a href='#patterns/math_actions@hexkinetics:get_vec_from/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='qaqeeqaq' data-start='west' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: qaqeeqaq</canvas></details><p>Combine two positions and create a list that includes those points as well as all block positions located between them.</p></div><br /></div><div id='patterns/actions'><h3 class='entry-title page-header'>HexKinetics Patterns<a href='#patterns/actions' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><div id='patterns/actions@hexkinetics:direction/const'><h4 class='pattern-title'>Alidade's Purification II (entity → vector)<a href='#patterns/actions@hexkinetics:direction/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='waa' data-start='east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: waa</canvas></details><p>Alidade's Purification but it returns the direction player is looking in form of full, round vectors, as (0,1,0).</p></div><br /><div id='patterns/actions@hexkinetics:pixel/raycast'><h4 class='pattern-title'>Sniper's Distillation (vector, vector → vector)<a href='#patterns/actions@hexkinetics:pixel/raycast' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='weqaqded' data-start='east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: weqaqded</canvas></details><p>Architect's Distillation but it  returns the precise hit position. Very versatile, it can be used on various entities and materials with the exception of air.</p></div><br /><div id='patterns/actions@hexkinetics:is_gravity/const'><h4 class='pattern-title'>Inertia Purification (entity → bool)<a href='#patterns/actions@hexkinetics:is_gravity/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='daad' data-start='east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: daad</canvas></details><p>Determines whether the entity is currently in a state of inertia or if it is subject to the force of gravity. If the entity is found to be in a state of inertia, purification returns true.</p></div><br /><div id='patterns/actions@hexkinetics:visibility/const'><h4 class='pattern-title'>Visibility Distillation (entity, vector → bool)<a href='#patterns/actions@hexkinetics:visibility/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='aqadwawaw' data-start='north_west' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: aqadwawaw</canvas></details><p>Returns whether a vector is currently within vision of an entity.</p></div><br /><div id='patterns/actions@hexkinetics:get_vehicle/const'><h4 class='pattern-title'>Vehicle Purification (entity → entity)<a href='#patterns/actions@hexkinetics:get_vehicle/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='qqdeewee' data-start='south_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: qqdeewee</canvas></details><p>Pops the entity off the stack and pushes a reference to the vehicle it is currently occupying. Returns Null if the entity is not riding any vehicle.</p></div><br /><div id='patterns/actions@hexkinetics:get_rider/const'><h4 class='pattern-title'>Jockey Purification (entity → entity)<a href='#patterns/actions@hexkinetics:get_rider/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='qqdeeaedeaee' data-start='south_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: qqdeeaedeaee</canvas></details><p>Pops the entity (vehicle) off the stack and pushes a reference to the entity that is currently occupying it. If vehicle has more than one passenger it returns the first one.</p></div><br /><div id='patterns/actions@hexkinetics:get_shooter/const'><h4 class='pattern-title'>Shooter Purification (entity → entity)<a href='#patterns/actions@hexkinetics:get_shooter/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='aadedade' data-start='east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: aadedade</canvas></details><p>It pops an object off the stack and pushes out the reference to the entity that fired it. Returns Null if the entity isn't a projectile. Only works if shooter is in your ambit.</p></div><br /></div></section><section id='patterns/spells'><h2 class='category-title page-header'>Spells<a href='#patterns/spells' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>Patterns and actions that perform a magical effect on the world.</p><div id='patterns/spells/spells'><h3 class='entry-title page-header'>HexKinetics Spells<a href='#patterns/spells/spells' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><div id='patterns/spells/spells@hexkinetics:lesser_teleport/spell'><h4 class='pattern-title'>Lesser Teleport (entity, vec/num →)<a href='#patterns/spells/spells@hexkinetics:lesser_teleport/spell' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='edqdewqaeaq' data-start='north_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: edqdewqaeaq</canvas></details><p>Takes entity and number or vector off the stack, then teleports the entity to its vector but with all fractions changed to given number, or fractions of every component changed to number in responding component in given vector.</p></div><br /><p>For example if given 5 and entity is on [35.11, 9.56, -10] it teleports it to [35.05, 9.05, -10.05]. It doesn't take numbers from 100 and up. Costs 1/5 of an amethyst dust.</p><br /><div id='patterns/spells/spells@hexkinetics:swap/spell'><h4 class='pattern-title'>Momentum Swap (entity, entity →)<a href='#patterns/spells/spells@hexkinetics:swap/spell' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='adaadaqedaddad' data-start='south_west' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: adaadaqedaddad</canvas></details><p>Swaps the motion of two entities. Costs 1 amethyst dust.</p></div><br /><div id='patterns/spells/spells@hexkinetics:projectile/spell'><h4 class='pattern-title'>Place Projectile (vector →)<a href='#patterns/spells/spells@hexkinetics:projectile/spell' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='weeeweede' data-start='south_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: weeeweede</canvas></details><p>Remove a location from the stack, then pick a projectile item and place it at the given location. The following items are currently compatible: normal, tipped, and spectral arrows, snowballs, eggs, tridents, ender pearls, eyes of ender, and fire charges. Costs 1 amethyst shard.</p></div><br /></div><div id='patterns/spells/rotate_spells'><h3 class='entry-title page-header'>Rotation Spells<a href='#patterns/spells/rotate_spells' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><div id='patterns/spells/rotate_spells@hexkinetics:rotate/spell'><h4 class='pattern-title'>Rotate (entity, vec →)<a href='#patterns/spells/rotate_spells@hexkinetics:rotate/spell' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='qqqadeeed' data-start='east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: qqqadeeed</canvas></details><p>Takes an entity and a vector as inputs and performs a rotation of the entity, to the direction indicated by the vector. It costs 1/8 of amethyst dust or if cast on another player it will cost one amethyst shard.</p></div><br /><div id='patterns/spells/rotate_spells@hexkinetics:rotate_two/spell'><h4 class='pattern-title'>Rotate II (entity, vec →)<a href='#patterns/spells/rotate_spells@hexkinetics:rotate_two/spell' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='eeedaqqqa' data-start='west' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: eeedaqqqa</canvas></details><p>Accepts an entity and a vector, rotates the entity motion direction in direction of a vector. If rotated to [0, 0, 0] it will completly stop its velocity. Costs 3/4 amethyst dust.</p></div><br /><div id='patterns/spells/rotate_spells@hexkinetics:rotate_block/spell'><h4 class='pattern-title'>Rotate: Block (vector, vector →)<a href='#patterns/spells/rotate_spells@hexkinetics:rotate_block/spell' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='qqqqqaqqqwadeeed' data-start='south_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: qqqqqaqqqwadeeed</canvas></details><p>Accepts a vector and a direction vector, rotates block at a given vector. Although it may appear to function similar to explosions, high explosion-resistant blocks are not affected. Costs 1/8 of amethyst dust.</p></div><br /></div></section><section id='patterns/great_spells'><h2 class='category-title page-header'>Great Spells<a href='#patterns/great_spells' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>The spells catalogued here are purported to be of legendary difficulty and power. They seem to have been recorded only sparsely (for good reason, the texts claim). It's probably just the hogwash of extinct traditionalists, though-- a pattern's a pattern. What could possibly go wrong?</p><div id='patterns/great_spells/greater_translocation'><h3 class='entry-title page-header'>Greater Translocation<a href='#patterns/great_spells/greater_translocation' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><div id='patterns/great_spells/greater_translocation@hexkinetics:move_block/spell'><h4 class='pattern-title'>Greater Translocation (vector, vector →)<a href='#patterns/great_spells/greater_translocation@hexkinetics:move_block/spell' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='eeqeeqeeeqeeqdeeqeqqwqqqeeqeqqwqq' data-start='south_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: eeqeeqeeeqeeqdeeqeqqwqqqeeqeqqwqq</canvas></details><p>This spell lets me teleport almost any block nearly anywhere in the entire world! There does seem to be a limit, but it is much greater than the normal radius of influence I am used to.</p></div><br /><p>The block will be teleported by the given vector, which is an offset from its given position. If block will be translocated to a harder block, the original block will be completely removed. If moved to a softer block, the destination block is destroyed, similary to using Break Block on it. In the case of blocks with equal hardness, the translocated block remains in place. Nature seems to struggle to find a solution in such instances, rendering the translocation ineffective, yet it still consumes amount of media needed for normal translocation.</p><br /><p>For distances up to 1 block, the charge is only one amethyst shard. If distance is greater than 1 block but not exceeding 100 blocks, the cost increases to 5 charged amethyst. When the distance falls within the range of 100 to 10,000 blocks, the cost becomes 10 charged amethyst. For distances larger than 10,000 blocks, the price rises to every additional block from 10,000 as amethyst shard plus 10 charged amethyst.</p><br /></div><div id='patterns/great_spells/great_spells'><h3 class='entry-title page-header'>Kinetics<a href='#patterns/great_spells/great_spells' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><div id='patterns/great_spells/great_spells@hexkinetics:zero_g/spell'><h4 class='pattern-title'>Twokai's Ideal Condition (entity, number →)<a href='#patterns/great_spells/great_spells@hexkinetics:zero_g/spell' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='wwqqqwadaadawqqqww' data-start='south_west' data-per-world=True>Your browser does not support visualizing patterns. Pattern code: wwqqqwadaadawqqqww</canvas></details><p>Makes an entity not affected by gravity or friction for certain amount of time.</p></div><br /><p>Which when combined with Impulse can make player go in a certain direction with given speed of a vector for given amount of time. Although it can be difficult to move on your own in this state of inertia. Costs units of Amethyst Dust equal to amount of time given times two. Unless time is 1 or less then it will cost only time.</p><br /><div id='patterns/great_spells/great_spells@hexkinetics:fast/spell'><h4 class='pattern-title'>Propulsion (entity, number, vector →)<a href='#patterns/great_spells/great_spells@hexkinetics:fast/spell' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='wqeqaaeeeweeeaaqeqqaaq' data-start='south_west' data-per-world=True>Your browser does not support visualizing patterns. Pattern code: wqeqaaeeeweeeaaqeqqaaq</canvas></details><p>This spell utilizes a vector to impulse a target entity, applying a continuous force over a duration determined by a given number.</p></div><br /><p>The force is exerted in intervals of 5 ticks (1/4 of a second). The duration is limited to a range of 0 to 200 units of time (50 seconds).  Costs length of the vector squared times time or if length of this vector is less then one it will cost one * time.</p><br /></div></section></main></div>
</body>
</html>
